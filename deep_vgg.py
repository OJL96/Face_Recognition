# -*- coding: utf-8 -*-
"""Deep VGG.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1REMRHIeAACSi0nimmZX7priCbFheZAnu
"""

#!pip install -U --pre tensorflow==1.15.0
#!pip install keras==2.2.4
#!pip uninstall keras
#!pip install h5py==1.10.4
import os
import cv2 as cv

import tensorflow as tf
print(tf.test.is_gpu_available())
print(f" Tensorflow version : {tf.__version__}")

import numpy as np
np.set_printoptions(suppress=True)

import matplotlib.pyplot as plt
from scipy.io import loadmat

X_test, y_test = np.load("X_test.npy"),\
                 np.asarray(loadmat("testLabel.mat")["testLabel"]).reshape(-1, 1)

X_train, y_train = np.load("X_train.npy"),\
                   np.load("y_train.npy").reshape(-1, 1)

print(f"{X_train.shape} | {X_test.shape} | {y_train.shape}  | {y_test.shape} ")

# peak at data
plt.imshow(X_train[2])

temp = []
for i in X_train:
  img = cv.resize(i, (224, 224))
  img = cv.cvtColor(img, cv.COLOR_BGR2RGB)
  temp.append(img)

X_train = np.asarray(temp)

temp.clear()
for i in X_test:
  img = cv.resize(i, (224, 224))
  img = cv.cvtColor(img, cv.COLOR_BGR2RGB)
  temp.append(img)

X_test = np.asarray(temp)

from tensorflow.keras.layers import ZeroPadding2D, Convolution2D, MaxPooling2D, Dropout, Flatten, Activation 
from tensorflow.keras.models import Sequential
model = Sequential()
model.add(ZeroPadding2D((1,1),input_shape=(224,224, 3)))
model.add(Convolution2D(64, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2,2), strides=(2,2)))

model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(128, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D((2,2), strides=(2,2)))

model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(256, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(256, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(256, (3, 3), activation='relu'))
model.add(MaxPooling2D((2,2), strides=(2,2)))

model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(MaxPooling2D((2,2), strides=(2,2)))

model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(ZeroPadding2D((1,1)))
model.add(Convolution2D(512, (3, 3), activation='relu'))
model.add(MaxPooling2D((2,2), strides=(2,2)))

model.add(Convolution2D(4096, (7, 7), activation='relu'))
model.add(Dropout(0.5))
model.add(Convolution2D(4096, (1, 1), activation='relu'))
model.add(Dropout(0.5))
model.add(Convolution2D(2622, (1, 1)))
model.add(Flatten())
model.add(Activation('softmax'))

print(len(model.layers))

#from keras.models import model_from_json
model.load_weights("vgg_face_weights.h5") # load weights into network
model.summary()

from tensorflow.keras.models import Model
vgg_face_descriptor = Model(inputs = model.layers[0].input, outputs = model.layers[-2].output)
#vgg_face_descriptor.summary()

def findCosineDistance(img1, img2):
  a = np.matmul(np.transpose(img1), img2)
  b = np.sum(np.multiply(img1, img1))
  c = np.sum(np.multiply(img2, img2))
  return 1 - (a / (np.sqrt(b) * np.sqrt(c)))

X_train = X_train / 255.
#X_train = 2* ( X_train / 255.) - 1
face_descriptor_train = np.asarray(vgg_face_descriptor.predict(X_train))
print(face_descriptor_train.shape)

X_test = X_test / 255.
#X_test = 2* ( X_test / 255.) - 1
face_descriptor_test = np.asarray(vgg_face_descriptor.predict(X_test))
print(face_descriptor_test.shape)

score, output = [], []
for i in face_descriptor_test:
  for ii in face_descriptor_train:
    dist = findCosineDistance(i, ii)
    score.append(dist)

  min_idx = np.argmin(score)
  output.append(y_train[min_idx])
  score.clear()

correct_p = 0
for i in range(len(y_test)):
  if output[i] == y_test[i]:
    correct_p += 1

print(f"Score: {round(correct_p / len(y_test), 3)}")

vgg_face_descriptor.save("VGG_model.h5") # save model in keras format